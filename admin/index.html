<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="MX BINGO - Real-time multiplayer BINGO with Neon Database">
    <meta name="theme-color" content="#4361ee">
    <title>ðŸŽ¯ MX BINGO</title>
    
    <!-- PWA -->
    <link rel="manifest" href="/manifest.json">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¯</text></svg>">
    
    <!-- Netlify Identity -->
    <script src="https://identity.netlify.com/v1/netlify-identity-widget.js" defer></script>
    
    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&family=Montserrat:wght@700;800;900&display=swap" rel="stylesheet">
    
    <style>
        /* Previous CSS remains the same, adding only new styles */
        
        /* ========== NEW: GAME LIST ========== */
        .games-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .game-card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border-radius: var(--border-radius);
            padding: 20px;
            border: 1px solid var(--glass-border);
            cursor: pointer;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary);
        }

        .game-card.active {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(6, 214, 160, 0.3);
        }

        .game-code {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 10px;
            font-family: 'Montserrat', sans-serif;
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 15px;
        }

        /* ========== NEW: CHAT SYSTEM ========== */
        .chat-container {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border-radius: var(--border-radius);
            border: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            box-shadow: var(--shadow-xl);
            transition: var(--transition);
        }

        .chat-header {
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .chat-input {
            display: flex;
            padding: 15px;
            border-top: 1px solid var(--glass-border);
        }

        .chat-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid var(--glass-border);
            background: rgba(0,0,0,0.2);
            color: white;
            border-radius: var(--border-radius-sm);
        }

        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: var(--border-radius-sm);
        }

        .message.admin {
            border-left: 3px solid var(--warning);
        }

        .message.player {
            border-left: 3px solid var(--success);
        }

        /* ========== NEW: CALLED NUMBERS ========== */
        .called-numbers {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 20px;
            justify-content: center;
        }

        .called-number {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            animation: popIn 0.3s ease;
        }

        /* ========== NEW: LEADERBOARD ========== */
        .leaderboard {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border-radius: var(--border-radius);
            padding: 20px;
            margin-top: 20px;
            border: 1px solid var(--glass-border);
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--glass-border);
        }

        .leaderboard-item:last-child {
            border-bottom: none;
        }

        .leaderboard-rank {
            width: 30px;
            height: 30px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            margin-right: 15px;
        }

        /* ========== NEW: WIN PATTERNS ========== */
        .pattern-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .pattern-btn {
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--glass-border);
            border-radius: var(--border-radius-sm);
            color: white;
            cursor: pointer;
            transition: var(--transition);
        }

        .pattern-btn.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        /* ========== TOUCH OPTIMIZATIONS ========== */
        @media (hover: none) and (pointer: coarse) {
            .cell {
                min-height: 60px;
            }
            
            .btn {
                min-height: 44px;
                min-width: 44px;
            }
            
            .game-header {
                padding: 15px;
            }
        }

        /* ========== DARK/LIGHT MODE ========== */
        @media (prefers-color-scheme: light) {
            :root {
                --glass-bg: rgba(255, 255, 255, 0.15);
                --glass-border: rgba(0, 0, 0, 0.1);
                --light: #212529;
                --dark: #f8f9fa;
            }
            
            body {
                background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
                color: var(--light);
            }
            
            .input-group input,
            .input-group select {
                background: rgba(255, 255, 255, 0.9);
                color: var(--light);
                border-color: rgba(0,0,0,0.1);
            }
        }
    </style>
</head>
<body>
    <!-- Background Elements -->
    <div class="background-overlay" id="backgroundOverlay"></div>
    
    <!-- Real-time Indicators -->
    <div class="realtime-indicator hidden" id="realtimeIndicator">
        <div class="status-dot connecting"></div>
        <span>Connecting...</span>
    </div>
    
    <div class="player-counter hidden" id="playerCounter">
        <i class="fas fa-users"></i>
        <span>0 Players</span>
    </div>

    <div class="container">
        <!-- Game Header -->
        <div class="game-header hidden" id="gameHeader">
            <div class="game-header-center">
                <div class="game-player-name" id="gamePlayerName">Player</div>
                <div id="calledNumbers" class="called-numbers"></div>
            </div>
            <div class="game-lucky-number" id="gameLuckyNumber">0000</div>
        </div>

        <!-- Game Selection Screen -->
        <div class="login-screen" id="gameSelectionScreen">
            <h2>ðŸŽ¯ MX BINGO</h2>
            
            <div class="input-group">
                <label for="playerName"><i class="fas fa-user"></i> Your Name</label>
                <input type="text" id="playerName" placeholder="Enter your name" autocomplete="name">
            </div>
            
            <div class="input-group">
                <label for="gameCode"><i class="fas fa-hashtag"></i> Game Code (Optional)</label>
                <input type="text" id="gameCode" placeholder="Enter existing game code" autocomplete="off">
                <small style="color: rgba(255,255,255,0.6); font-size: 0.85rem; display: block; margin-top: 5px;">
                    Leave empty to create new game
                </small>
            </div>
            
            <button class="btn btn-primary btn-block" id="joinGameBtn">
                <i class="fas fa-play"></i> Start Playing
            </button>
            
            <div class="mt-3 text-center">
                <button class="btn btn-secondary" id="showGamesBtn">
                    <i class="fas fa-list"></i> Browse Active Games
                </button>
            </div>
            
            <div class="text-center mt-3">
                <small style="color: rgba(255,255,255,0.6);">
                    Admin? <a href="/admin" style="color: #FF6B35; text-decoration: none; font-weight: 600;">Access Panel</a>
                </small>
            </div>
        </div>

        <!-- Game Browser -->
        <div class="login-screen hidden" id="gamesBrowser">
            <h2><i class="fas fa-gamepad"></i> Active Games</h2>
            <div class="games-container" id="gamesContainer">
                <!-- Games will be loaded here -->
            </div>
            <button class="btn btn-secondary btn-block mt-3" id="backToJoinBtn">
                <i class="fas fa-arrow-left"></i> Back
            </button>
        </div>

        <!-- Game Screen -->
        <div class="card-container hidden" id="gameScreen">
            <div class="game-status">
                <div class="status-dot" id="statusDot"></div>
                <div style="flex: 1;">
                    <span id="statusText">Connected</span>
                    <div style="font-size: 0.8rem; color: rgba(255,255,255,0.6);" id="gameInfo">
                        Game: <span id="currentGameCode">-</span>
                    </div>
                </div>
                <button class="btn btn-secondary btn-small" id="gameSettingsBtn">
                    <i class="fas fa-cog"></i>
                </button>
            </div>
            
            <!-- Pattern Selector -->
            <div class="pattern-selector" id="patternSelector">
                <button class="pattern-btn active" data-pattern="any">Any Line</button>
                <button class="pattern-btn" data-pattern="horizontal">Horizontal</button>
                <button class="pattern-btn" data-pattern="vertical">Vertical</button>
                <button class="pattern-btn" data-pattern="diagonal">Diagonal</button>
                <button class="pattern-btn" data-pattern="corners">Four Corners</button>
                <button class="pattern-btn" data-pattern="full">Full House</button>
            </div>
            
            <!-- Bingo Card -->
            <div class="bingo-card">
                <div class="card-header">
                    <h3 id="cardTitle">BINGO CARD 1/3</h3>
                    <p>Pattern: <span id="currentPattern">Any Line</span></p>
                </div>
                
                <div class="bingo-grid" id="bingoGrid">
                    <!-- Generated dynamically -->
                </div>
            </div>
            
            <!-- Navigation -->
            <div class="card-nav">
                <button class="btn btn-secondary" id="prevCardBtn">
                    <i class="fas fa-chevron-left"></i> Back
                </button>
                <button class="btn btn-danger" id="clearCardBtn">
                    <i class="fas fa-eraser"></i> Clear
                </button>
                <button class="btn btn-secondary" id="nextCardBtn">
                    Next <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            
            <!-- Game Controls -->
            <div class="game-controls">
                <button class="btn btn-success" id="claimBingoBtn">
                    <i class="fas fa-trophy"></i> Claim BINGO!
                </button>
                <button class="btn btn-secondary" id="chatToggleBtn">
                    <i class="fas fa-comments"></i> Chat
                </button>
                <button class="btn btn-secondary" id="leaderboardBtn">
                    <i class="fas fa-chart-bar"></i> Leaderboard
                </button>
                <button class="btn btn-secondary" id="fullscreenBtn">
                    <i class="fas fa-expand"></i>
                </button>
                <button class="btn btn-danger" id="leaveGameBtn">
                    <i class="fas fa-sign-out-alt"></i> Leave
                </button>
            </div>
        </div>

        <!-- Chat Container -->
        <div class="chat-container hidden" id="chatContainer">
            <div class="chat-header">
                <span><i class="fas fa-comments"></i> Game Chat</span>
                <button class="btn btn-small" id="closeChatBtn" style="padding: 2px 8px; font-size: 0.8rem;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="chat-messages" id="chatMessages">
                <!-- Messages will appear here -->
            </div>
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Type a message..." autocomplete="off">
                <button class="btn btn-primary" id="sendMessageBtn" style="margin-left: 10px;">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Modals & Notifications -->
    <div class="notification hidden" id="notification">
        <i class="fas fa-check-circle"></i>
        <span id="notificationText">Welcome to MX BINGO!</span>
    </div>

    <div class="modal-overlay hidden" id="loadingModal">
        <div class="modal">
            <div class="loading">
                <div class="spinner"></div>
                <p id="loadingText">Connecting...</p>
            </div>
        </div>
    </div>

    <!-- Game Settings Modal -->
    <div class="modal-overlay hidden" id="settingsModal">
        <div class="modal">
            <h3 style="margin-bottom: 20px; color: white;">
                <i class="fas fa-cog"></i> Game Settings
            </h3>
            <div class="input-group">
                <label for="soundToggle">
                    <i class="fas fa-volume-up"></i> Sound Effects
                </label>
                <select id="soundToggle">
                    <option value="on">On</option>
                    <option value="off">Off</option>
                </select>
            </div>
            <div class="input-group">
                <label for="vibrationToggle">
                    <i class="fas fa-vibrate"></i> Vibration
                </label>
                <select id="vibrationToggle">
                    <option value="on">On</option>
                    <option value="off">Off</option>
                </select>
            </div>
            <div class="input-group">
                <label for="autoMarkToggle">
                    <i class="fas fa-magic"></i> Auto-mark Called Numbers
                </label>
                <select id="autoMarkToggle">
                    <option value="on">On</option>
                    <option value="off">Off</option>
                </select>
            </div>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-secondary" id="closeSettingsBtn">Close</button>
                <button class="btn btn-primary" id="saveSettingsBtn">Save</button>
            </div>
        </div>
    </div>

    <!-- BINGO Winner Modal -->
    <div class="winning-overlay hidden" id="winnerModal">
        <div class="winning-message">
            <h1>ðŸŽ‰ BINGO! ðŸŽ‰</h1>
            <p style="font-size: 1.2rem; margin-bottom: 20px;" id="winnerMessage">
                Congratulations! You've won!
            </p>
            <button class="btn btn-success" id="continuePlayingBtn">
                <i class="fas fa-play"></i> Continue Playing
            </button>
            <button class="btn btn-secondary" id="newGameBtn" style="margin-top: 10px;">
                <i class="fas fa-plus"></i> New Game
            </button>
        </div>
    </div>

    <script>
        // ========== CONFIGURATION ==========
        const CONFIG = {
            API_BASE: '/.netlify/functions',
            WEBSOCKET_URL: window.location.protocol === 'https:' 
                ? `wss://${window.location.host}/.netlify/functions/websocket`
                : `ws://${window.location.host}/.netlify/functions/websocket`,
            RECONNECT_DELAY: 3000,
            MAX_RECONNECT_ATTEMPTS: 5
        };

        // ========== STATE MANAGEMENT ==========
        let state = {
            user: null,
            game: null,
            connection: null,
            cards: [],
            currentCardIndex: 0,
            markedCells: new Set(),
            calledNumbers: [],
            players: [],
            settings: {
                sound: true,
                vibration: true,
                autoMark: true,
                pattern: 'any'
            },
            chat: {
                visible: false,
                messages: []
            }
        };

        // ========== DOM ELEMENTS ==========
        const elements = {
            // Screens
            gameSelectionScreen: document.getElementById('gameSelectionScreen'),
            gamesBrowser: document.getElementById('gamesBrowser'),
            gameScreen: document.getElementById('gameScreen'),
            
            // Game Selection
            playerName: document.getElementById('playerName'),
            gameCode: document.getElementById('gameCode'),
            joinGameBtn: document.getElementById('joinGameBtn'),
            showGamesBtn: document.getElementById('showGamesBtn'),
            backToJoinBtn: document.getElementById('backToJoinBtn'),
            gamesContainer: document.getElementById('gamesContainer'),
            
            // Game Screen
            gameHeader: document.getElementById('gameHeader'),
            gamePlayerName: document.getElementById('gamePlayerName'),
            gameLuckyNumber: document.getElementById('gameLuckyNumber'),
            currentGameCode: document.getElementById('currentGameCode'),
            bingoGrid: document.getElementById('bingoGrid'),
            cardTitle: document.getElementById('cardTitle'),
            currentPattern: document.getElementById('currentPattern'),
            calledNumbers: document.getElementById('calledNumbers'),
            
            // Navigation
            prevCardBtn: document.getElementById('prevCardBtn'),
            nextCardBtn: document.getElementById('nextCardBtn'),
            clearCardBtn: document.getElementById('clearCardBtn'),
            leaveGameBtn: document.getElementById('leaveGameBtn'),
            
            // Controls
            patternSelector: document.getElementById('patternSelector'),
            claimBingoBtn: document.getElementById('claimBingoBtn'),
            chatToggleBtn: document.getElementById('chatToggleBtn'),
            leaderboardBtn: document.getElementById('leaderboardBtn'),
            fullscreenBtn: document.getElementById('fullscreenBtn'),
            gameSettingsBtn: document.getElementById('gameSettingsBtn'),
            
            // Chat
            chatContainer: document.getElementById('chatContainer'),
            chatMessages: document.getElementById('chatMessages'),
            chatInput: document.getElementById('chatInput'),
            sendMessageBtn: document.getElementById('sendMessageBtn'),
            closeChatBtn: document.getElementById('closeChatBtn'),
            
            // Status
            realtimeIndicator: document.getElementById('realtimeIndicator'),
            playerCounter: document.getElementById('playerCounter'),
            statusDot: document.getElementById('statusDot'),
            statusText: document.getElementById('statusText'),
            
            // Modals
            notification: document.getElementById('notification'),
            notificationText: document.getElementById('notificationText'),
            loadingModal: document.getElementById('loadingModal'),
            loadingText: document.getElementById('loadingText'),
            settingsModal: document.getElementById('settingsModal'),
            winnerModal: document.getElementById('winnerModal'),
            winnerMessage: document.getElementById('winnerMessage'),
            
            // Background
            backgroundOverlay: document.getElementById('backgroundOverlay')
        };

        // ========== UTILITY FUNCTIONS ==========
        const utils = {
            showNotification(message, type = 'success') {
                elements.notificationText.textContent = message;
                elements.notification.className = `notification ${type}`;
                elements.notification.classList.remove('hidden');
                
                const icon = elements.notification.querySelector('i');
                icon.className = type === 'success' ? 'fas fa-check-circle' : 
                                type === 'error' ? 'fas fa-exclamation-circle' : 
                                'fas fa-info-circle';
                
                setTimeout(() => {
                    elements.notification.classList.add('hidden');
                }, 3000);
            },

            showLoading(message) {
                elements.loadingText.textContent = message;
                elements.loadingModal.classList.remove('hidden');
            },

            hideLoading() {
                elements.loadingModal.classList.add('hidden');
            },

            playSound(type) {
                if (!state.settings.sound) return;
                
                const sounds = {
                    mark: new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEAQB8AAEAfAAABAAgAZGF0YQ'),
                    bingo: new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEAQB8AAEAfAAABAAgAZGF0YQ'),
                    win: new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEAQB8AAEAfAAABAAgAZGF0YQ')
                };
                
                if (sounds[type]) {
                    sounds[type].play().catch(() => {});
                }
            },

            vibrate(pattern = [100]) {
                if (!state.settings.vibration || !navigator.vibrate) return;
                navigator.vibrate(pattern);
            },

            generateGameCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            },

            generateLuckyNumber() {
                return Math.floor(1000 + Math.random() * 9000).toString();
            },

            generateBingoCard() {
                const card = [];
                for (let col = 0; col < 5; col++) {
                    const numbers = new Set();
                    while (numbers.size < 5) {
                        const min = col * 15 + 1;
                        const max = min + 14;
                        numbers.add(Math.floor(Math.random() * (max - min + 1)) + min);
                    }
                    card.push(...Array.from(numbers));
                }
                card[12] = 'FREE';
                return card;
            },

            checkBingo(pattern = state.settings.pattern) {
                const marked = Array.from(state.markedCells);
                const gridSize = 5;
                
                switch (pattern) {
                    case 'horizontal':
                        for (let row = 0; row < gridSize; row++) {
                            let complete = true;
                            for (let col = 0; col < gridSize; col++) {
                                const index = row * gridSize + col;
                                if (index === 12) continue; // FREE space
                                if (!marked.includes(index)) {
                                    complete = false;
                                    break;
                                }
                            }
                            if (complete) return true;
                        }
                        break;
                        
                    case 'vertical':
                        for (let col = 0; col < gridSize; col++) {
                            let complete = true;
                            for (let row = 0; row < gridSize; row++) {
                                const index = row * gridSize + col;
                                if (index === 12) continue;
                                if (!marked.includes(index)) {
                                    complete = false;
                                    break;
                                }
                            }
                            if (complete) return true;
                        }
                        break;
                        
                    case 'diagonal':
                        let diag1 = true, diag2 = true;
                        for (let i = 0; i < gridSize; i++) {
                            const index1 = i * gridSize + i;
                            const index2 = i * gridSize + (gridSize - 1 - i);
                            if (index1 !== 12 && !marked.includes(index1)) diag1 = false;
                            if (index2 !== 12 && !marked.includes(index2)) diag2 = false;
                        }
                        if (diag1 || diag2) return true;
                        break;
                        
                    case 'corners':
                        const corners = [0, 4, 20, 24];
                        if (corners.every(corner => marked.includes(corner))) return true;
                        break;
                        
                    case 'full':
                        const totalCells = gridSize * gridSize;
                        let markedCount = marked.length;
                        if (marked.includes(12)) markedCount--; // FREE space doesn't count
                        if (markedCount === totalCells - 1) return true; // All except FREE
                        break;
                        
                    case 'any':
                    default:
                        // Check all patterns
                        return ['horizontal', 'vertical', 'diagonal', 'corners'].some(p => 
                            utils.checkBingo(p)
                        );
                }
                
                return false;
            },

            saveToLocalStorage() {
                const gameData = {
                    user: state.user,
                    cards: state.cards,
                    markedCells: Array.from(state.markedCells),
                    settings: state.settings
                };
                localStorage.setItem(`mx_bingo_${state.game?.code}`, JSON.stringify(gameData));
            },

            loadFromLocalStorage(gameCode) {
                const saved = localStorage.getItem(`mx_bingo_${gameCode}`);
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        state.user = data.user;
                        state.cards = data.cards;
                        state.markedCells = new Set(data.markedCells);
                        state.settings = { ...state.settings, ...data.settings };
                        return true;
                    } catch (e) {
                        console.error('Failed to load saved data:', e);
                    }
                }
                return false;
            }
        };

        // ========== API FUNCTIONS ==========
        const api = {
            async createGame(playerName) {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/create-game`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ playerName })
                    });
                    
                    if (!response.ok) throw new Error('Failed to create game');
                    return await response.json();
                } catch (error) {
                    console.error('Create game error:', error);
                    throw error;
                }
            },

            async joinGame(gameCode, playerName) {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/join-game`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ gameCode, playerName })
                    });
                    
                    if (!response.ok) throw new Error('Failed to join game');
                    return await response.json();
                } catch (error) {
                    console.error('Join game error:', error);
                    throw error;
                }
            },

            async getActiveGames() {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/active-games`);
                    if (!response.ok) throw new Error('Failed to fetch games');
                    return await response.json();
                } catch (error) {
                    console.error('Get games error:', error);
                    return [];
                }
            },

            async callNumber(gameCode) {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/call-number`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ gameCode })
                    });
                    return await response.json();
                } catch (error) {
                    console.error('Call number error:', error);
                }
            },

            async claimBingo(gameCode, playerId, pattern) {
                try {
                    const response = await fetch(`${CONFIG.API_BASE}/claim-bingo`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ gameCode, playerId, pattern })
                    });
                    return await response.json();
                } catch (error) {
                    console.error('Claim bingo error:', error);
                }
            }
        };

        // ========== WEBSOCKET CONNECTION ==========
        class GameConnection {
            constructor() {
                this.ws = null;
                this.reconnectAttempts = 0;
                this.listeners = new Map();
            }

            connect(gameCode) {
                return new Promise((resolve, reject) => {
                    try {
                        this.ws = new WebSocket(`${CONFIG.WEBSOCKET_URL}?game=${gameCode}`);
                        
                        this.ws.onopen = () => {
                            console.log('WebSocket connected');
                            this.reconnectAttempts = 0;
                            this.updateStatus('connected');
                            resolve();
                        };
                        
                        this.ws.onmessage = (event) => {
                            try {
                                const data = JSON.parse(event.data);
                                this.handleMessage(data);
                            } catch (e) {
                                console.error('Failed to parse message:', e);
                            }
                        };
                        
                        this.ws.onclose = () => {
                            console.log('WebSocket disconnected');
                            this.updateStatus('disconnected');
                            this.attemptReconnect(gameCode);
                        };
                        
                        this.ws.onerror = (error) => {
                            console.error('WebSocket error:', error);
                            reject(error);
                        };
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            handleMessage(data) {
                switch (data.type) {
                    case 'player_joined':
                        this.handlePlayerJoined(data);
                        break;
                    case 'player_left':
                        this.handlePlayerLeft(data);
                        break;
                    case 'number_called':
                        this.handleNumberCalled(data);
                        break;
                    case 'bingo_claimed':
                        this.handleBingoClaimed(data);
                        break;
                    case 'chat_message':
                        this.handleChatMessage(data);
                        break;
                    case 'game_update':
                        this.handleGameUpdate(data);
                        break;
                }
                
                // Notify listeners
                this.listeners.forEach(callback => callback(data));
            }

            handlePlayerJoined(data) {
                utils.showNotification(`${data.playerName} joined the game!`);
                this.updatePlayerCount(data.playerCount);
            }

            handlePlayerLeft(data) {
                utils.showNotification(`${data.playerName} left the game`, 'warning');
                this.updatePlayerCount(data.playerCount);
            }

            handleNumberCalled(data) {
                state.calledNumbers.push(data.number);
                this.updateCalledNumbers();
                
                if (state.settings.autoMark) {
                    this.autoMarkNumber(data.number);
                }
                
                utils.playSound('mark');
                utils.vibrate([100, 50, 100]);
            }

            handleBingoClaimed(data) {
                if (data.playerId === state.user?.id) {
                    // Player won
                    elements.winnerMessage.textContent = `Congratulations ${state.user.name}! You won with ${data.pattern} pattern!`;
                    elements.winnerModal.classList.remove('hidden');
                    utils.playSound('win');
                    utils.vibrate([200, 100, 200, 100, 200]);
                } else {
                    // Another player won
                    utils.showNotification(`${data.playerName} won with ${data.pattern}!`, 'warning');
                }
            }

            handleChatMessage(data) {
                state.chat.messages.push(data);
                this.updateChat();
            }

            handleGameUpdate(data) {
                if (data.settings) {
                    this.applyGameSettings(data.settings);
                }
                if (data.background) {
                    this.applyBackground(data.background);
                }
            }

            autoMarkNumber(number) {
                state.cards[state.currentCardIndex].forEach((cell, index) => {
                    if (cell === number && !state.markedCells.has(index)) {
                        state.markedCells.add(index);
                        this.updateCell(index, true);
                    }
                });
            }

            updateCalledNumbers() {
                elements.calledNumbers.innerHTML = state.calledNumbers
                    .slice(-10) // Show last 10 numbers
                    .map(num => `<div class="called-number">${num}</div>`)
                    .join('');
            }

            updatePlayerCount(count) {
                elements.playerCounter.innerHTML = `
                    <i class="fas fa-users"></i>
                    <span>${count} Player${count !== 1 ? 's' : ''}</span>
                `;
                elements.playerCounter.classList.remove('hidden');
            }

            updateStatus(status) {
                const statusMap = {
                    connected: { text: 'Connected', dot: 'active', indicator: 'LIVE' },
                    disconnected: { text: 'Disconnected', dot: 'inactive', indicator: 'OFFLINE' },
                    connecting: { text: 'Connecting...', dot: 'connecting', indicator: 'CONNECTING' }
                };
                
                const { text, dot, indicator } = statusMap[status] || statusMap.disconnected;
                
                elements.statusText.textContent = text;
                elements.statusDot.className = `status-dot ${dot}`;
                elements.realtimeIndicator.innerHTML = `
                    <div class="status-dot ${dot}"></div>
                    <span>${indicator}</span>
                `;
                elements.realtimeIndicator.classList.remove('hidden');
            }

            updateCell(index, marked) {
                const cell = elements.bingoGrid.children[index];
                if (cell) {
                    cell.classList.toggle('marked', marked);
                }
            }

            updateChat() {
                elements.chatMessages.innerHTML = state.chat.messages
                    .slice(-20) // Show last 20 messages
                    .map(msg => `
                        <div class="message ${msg.type}">
                            <strong>${msg.playerName}:</strong> ${msg.text}
                            <small style="opacity: 0.6; font-size: 0.8rem;">
                                ${new Date(msg.timestamp).toLocaleTimeString()}
                            </small>
                        </div>
                    `)
                    .join('');
                
                // Scroll to bottom
                elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
            }

            applyGameSettings(settings) {
                if (settings.cellColor) {
                    document.documentElement.style.setProperty('--cell-bg', settings.cellColor);
                }
                if (settings.playerNameColor) {
                    elements.gamePlayerName.style.color = settings.playerNameColor;
                }
                // Add more settings as needed
            }

            applyBackground(background) {
                if (background.type === 'image' && background.url) {
                    document.body.style.backgroundImage = `url('${background.url}')`;
                    document.body.style.backgroundSize = 'cover';
                } else if (background.type === 'gradient') {
                    document.body.style.background = 
                        `linear-gradient(${background.angle}deg, ${background.color1}, ${background.color2})`;
                }
            }

            attemptReconnect(gameCode) {
                if (this.reconnectAttempts >= CONFIG.MAX_RECONNECT_ATTEMPTS) {
                    utils.showNotification('Failed to reconnect. Please refresh the page.', 'error');
                    return;
                }
                
                this.reconnectAttempts++;
                this.updateStatus('connecting');
                
                setTimeout(() => {
                    if (state.game) {
                        this.connect(state.game.code).catch(() => {
                            this.attemptReconnect(gameCode);
                        });
                    }
                }, CONFIG.RECONNECT_DELAY * this.reconnectAttempts);
            }

            send(data) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(data));
                }
            }

            on(event, callback) {
                this.listeners.set(event, callback);
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                this.listeners.clear();
            }
        }

        // ========== GAME RENDERING ==========
        const renderer = {
            renderBingoGrid(card) {
                elements.bingoGrid.innerHTML = '';
                
                for (let i = 0; i < 25; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.textContent = card[i];
                    cell.dataset.index = i;
                    
                    if (card[i] === 'FREE') {
                        cell.classList.add('free');
                    }
                    
                    if (state.markedCells.has(i)) {
                        cell.classList.add('marked');
                    }
                    
                    cell.addEventListener('click', () => this.toggleCell(i));
                    elements.bingoGrid.appendChild(cell);
                }
                
                // Apply cell styling from settings
                document.querySelectorAll('#bingoGrid .cell').forEach(cell => {
                    cell.style.backgroundColor = 'var(--cell-bg, rgba(255,255,255,0.1))';
                    cell.style.color = 'var(--cell-color, white)';
                });
            },

            toggleCell(index) {
                const cell = state.cards[state.currentCardIndex][index];
                if (cell === 'FREE') return;
                
                if (state.markedCells.has(index)) {
                    state.markedCells.delete(index);
                } else {
                    state.markedCells.add(index);
                    utils.playSound('mark');
                    utils.vibrate([50]);
                }
                
                utils.saveToLocalStorage();
                
                // Check for BINGO
                if (utils.checkBingo()) {
                    elements.claimBingoBtn.classList.add('pulse');
                    utils.playSound('bingo');
                }
                
                this.updateCell(index);
            },

            updateCell(index) {
                const cell = elements.bingoGrid.children[index];
                if (cell) {
                    const isMarked = state.markedCells.has(index);
                    cell.classList.toggle('marked', isMarked);
                }
            },

            renderGamesList(games) {
                elements.gamesContainer.innerHTML = games.map(game => `
                    <div class="game-card ${game.active ? 'active' : ''}" data-code="${game.code}">
                        <div class="game-code">${game.code}</div>
                        <div style="color: rgba(255,255,255,0.8); margin-bottom: 10px;">
                            ${game.name || 'MX BINGO Game'}
                        </div>
                        <div class="game-stats">
                            <span><i class="fas fa-users"></i> ${game.playerCount || 0}</span>
                            <span><i class="fas fa-clock"></i> ${new Date(game.createdAt).toLocaleDateString()}</span>
                        </div>
                        ${game.hostName ? `<div style="margin-top: 10px; font-size: 0.9rem; color: rgba(255,255,255,0.6);">
                            Host: ${game.hostName}
                        </div>` : ''}
                    </div>
                `).join('');
                
                // Add click handlers
                document.querySelectorAll('.game-card').forEach(card => {
                    card.addEventListener('click', () => {
                        const gameCode = card.dataset.code;
                        elements.gameCode.value = gameCode;
                        elements.gamesBrowser.classList.add('hidden');
                        elements.gameSelectionScreen.classList.remove('hidden');
                    });
                });
            },

            updateCardNavigation() {
                const totalCards = state.cards.length;
                elements.cardTitle.textContent = `BINGO CARD ${state.currentCardIndex + 1}/${totalCards}`;
                
                elements.prevCardBtn.disabled = state.currentCardIndex === 0;
                elements.nextCardBtn.disabled = state.currentCardIndex === totalCards - 1;
                
                this.renderBingoGrid(state.cards[state.currentCardIndex]);
            }
        };

        // ========== EVENT HANDLERS ==========
        const setupEventHandlers = () => {
            // Game Selection
            elements.joinGameBtn.addEventListener('click', handleJoinGame);
            elements.showGamesBtn.addEventListener('click', handleShowGames);
            elements.backToJoinBtn.addEventListener('click', handleBackToJoin);
            
            // Game Navigation
            elements.prevCardBtn.addEventListener('click', handlePrevCard);
            elements.nextCardBtn.addEventListener('click', handleNextCard);
            elements.clearCardBtn.addEventListener('click', handleClearCard);
            elements.leaveGameBtn.addEventListener('click', handleLeaveGame);
            
            // Game Controls
            elements.patternSelector.addEventListener('click', handlePatternChange);
            elements.claimBingoBtn.addEventListener('click', handleClaimBingo);
            elements.chatToggleBtn.addEventListener('click', handleChatToggle);
            elements.leaderboardBtn.addEventListener('click', handleShowLeaderboard);
            elements.fullscreenBtn.addEventListener('click', handleFullscreen);
            elements.gameSettingsBtn.addEventListener('click', handleGameSettings);
            
            // Chat
            elements.sendMessageBtn.addEventListener('click', handleSendMessage);
            elements.closeChatBtn.addEventListener('click', handleCloseChat);
            elements.chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleSendMessage();
            });
            
            // Modals
            elements.closeSettingsBtn.addEventListener('click', () => {
                elements.settingsModal.classList.add('hidden');
            });
            elements.saveSettingsBtn.addEventListener('click', handleSaveSettings);
            elements.continuePlayingBtn.addEventListener('click', () => {
                elements.winnerModal.classList.add('hidden');
            });
            elements.newGameBtn.addEventListener('click', handleNewGame);
            
            // Fullscreen
            document.addEventListener('fullscreenchange', () => {
                elements.fullscreenBtn.innerHTML = document.fullscreenElement 
                    ? '<i class="fas fa-compress"></i>'
                    : '<i class="fas fa-expand"></i>';
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.matches('input, textarea')) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        if (!elements.prevCardBtn.disabled) handlePrevCard();
                        break;
                    case 'ArrowRight':
                        if (!elements.nextCardBtn.disabled) handleNextCard();
                        break;
                    case ' ':
                        e.preventDefault();
                        const hovered = document.querySelector('#bingoGrid .cell:hover');
                        if (hovered) hovered.click();
                        break;
                    case 'Escape':
                        if (elements.chatContainer.classList.contains('hidden')) {
                            handleLeaveGame();
                        } else {
                            handleCloseChat();
                        }
                        break;
                }
            });
            
            // Player name auto-focus
            elements.playerName.focus();
        };

        // ========== EVENT HANDLER FUNCTIONS ==========
        async function handleJoinGame() {
            const playerName = elements.playerName.value.trim();
            const gameCode = elements.gameCode.value.trim().toUpperCase();
            
            if (!playerName) {
                utils.showNotification('Please enter your name', 'error');
                return;
            }
            
            utils.showLoading(gameCode ? 'Joining game...' : 'Creating game...');
            
            try {
                let gameData;
                
                if (gameCode) {
                    // Join existing game
                    gameData = await api.joinGame(gameCode, playerName);
                } else {
                    // Create new game
                    gameData = await api.createGame(playerName);
                }
                
                // Setup state
                state.user = {
                    id: gameData.playerId,
                    name: playerName,
                    luckyNumber: utils.generateLuckyNumber()
                };
                
                state.game = {
                    code: gameData.gameCode,
                    name: gameData.gameName,
                    hostId: gameData.hostId
                };
                
                // Generate cards
                state.cards = [];
                for (let i = 0; i < 3; i++) {
                    state.cards.push(utils.generateBingoCard());
                }
                
                // Connect to WebSocket
                state.connection = new GameConnection();
                await state.connection.connect(gameData.gameCode);
                
                // Switch to game screen
                elements.gameSelectionScreen.classList.add('hidden');
                elements.gameScreen.classList.remove('hidden');
                elements.gameHeader.classList.remove('hidden');
                
                // Update UI
                elements.gamePlayerName.textContent = playerName;
                elements.gameLuckyNumber.textContent = state.user.luckyNumber;
                elements.currentGameCode.textContent = gameData.gameCode;
                
                renderer.updateCardNavigation();
                
                utils.hideLoading();
                utils.showNotification(`Welcome to ${gameData.gameName || 'MX BINGO'}!`);
                
            } catch (error) {
                utils.hideLoading();
                utils.showNotification(error.message || 'Failed to join game', 'error');
            }
        }

        async function handleShowGames() {
            utils.showLoading('Loading games...');
            
            try {
                const games = await api.getActiveGames();
                renderer.renderGamesList(games);
                
                elements.gameSelectionScreen.classList.add('hidden');
                elements.gamesBrowser.classList.remove('hidden');
            } catch (error) {
                utils.showNotification('Failed to load games', 'error');
            } finally {
                utils.hideLoading();
            }
        }

        function handleBackToJoin() {
            elements.gamesBrowser.classList.add('hidden');
            elements.gameSelectionScreen.classList.remove('hidden');
        }

        function handlePrevCard() {
            if (state.currentCardIndex > 0) {
                utils.saveToLocalStorage();
                state.currentCardIndex--;
                renderer.updateCardNavigation();
            }
        }

        function handleNextCard() {
            if (state.currentCardIndex < state.cards.length - 1) {
                utils.saveToLocalStorage();
                state.currentCardIndex++;
                renderer.updateCardNavigation();
            }
        }

        async function handleClearCard() {
            if (confirm('Clear all marks on this card?')) {
                state.markedCells.clear();
                renderer.updateCardNavigation();
                utils.saveToLocalStorage();
                utils.showNotification('Card cleared');
            }
        }

        async function handleClaimBingo() {
            if (!utils.checkBingo()) {
                utils.showNotification('No BINGO pattern found!', 'error');
                return;
            }
            
            const confirmed = confirm(`Claim BINGO with ${state.settings.pattern} pattern?`);
            if (confirmed) {
                try {
                    await api.claimBingo(
                        state.game.code,
                        state.user.id,
                        state.settings.pattern
                    );
                    utils.showNotification('BINGO claimed! Waiting for verification...');
                } catch (error) {
                    utils.showNotification('Failed to claim BINGO', 'error');
                }
            }
        }

        function handleChatToggle() {
            state.chat.visible = !state.chat.visible;
            elements.chatContainer.classList.toggle('hidden', !state.chat.visible);
            
            if (state.chat.visible) {
                elements.chatInput.focus();
            }
        }

        function handleSendMessage() {
            const text = elements.chatInput.value.trim();
            if (!text) return;
            
            state.connection.send({
                type: 'chat_message',
                playerId: state.user.id,
                playerName: state.user.name,
                text: text,
                timestamp: new Date().toISOString()
            });
            
            elements.chatInput.value = '';
        }

        function handleCloseChat() {
            state.chat.visible = false;
            elements.chatContainer.classList.add('hidden');
        }

        async function handleShowLeaderboard() {
            // TODO: Implement leaderboard
            utils.showNotification('Leaderboard coming soon!', 'warning');
        }

        function handleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(console.error);
            } else {
                document.exitFullscreen();
            }
        }

        function handleGameSettings() {
            elements.settingsModal.classList.remove('hidden');
        }

        function handleSaveSettings() {
            state.settings.sound = document.getElementById('soundToggle').value === 'on';
            state.settings.vibration = document.getElementById('vibrationToggle').value === 'on';
            state.settings.autoMark = document.getElementById('autoMarkToggle').value === 'on';
            
            utils.saveToLocalStorage();
            elements.settingsModal.classList.add('hidden');
            utils.showNotification('Settings saved');
        }

        function handlePatternChange(e) {
            if (e.target.classList.contains('pattern-btn')) {
                document.querySelectorAll('.pattern-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                e.target.classList.add('active');
                state.settings.pattern = e.target.dataset.pattern;
                elements.currentPattern.textContent = 
                    e.target.dataset.pattern.charAt(0).toUpperCase() + 
                    e.target.dataset.pattern.slice(1).replace('_', ' ');
                
                utils.saveToLocalStorage();
            }
        }

        function handleLeaveGame() {
            if (confirm('Leave the game? Your progress will be saved.')) {
                if (state.connection) {
                    state.connection.disconnect();
                }
                
                utils.saveToLocalStorage();
                
                elements.gameScreen.classList.add('hidden');
                elements.gameHeader.classList.add('hidden');
                elements.gameSelectionScreen.classList.remove('hidden');
                
                // Reset state
                state = {
                    user: null,
                    game: null,
                    connection: null,
                    cards: [],
                    currentCardIndex: 0,
                    markedCells: new Set(),
                    calledNumbers: [],
                    players: [],
                    settings: { ...state.settings },
                    chat: { visible: false, messages: [] }
                };
                
                utils.showNotification('Left the game. Progress saved.');
            }
        }

        function handleNewGame() {
            elements.winnerModal.classList.add('hidden');
            handleLeaveGame();
        }

        // ========== INITIALIZATION ==========
        const init = () => {
            setupEventHandlers();
            
            // Check for saved game in URL
            const urlParams = new URLSearchParams(window.location.search);
            const savedGameCode = urlParams.get('game');
            if (savedGameCode) {
                elements.gameCode.value = savedGameCode;
            }
            
            // Initialize Netlify Identity
            if (window.netlifyIdentity) {
                netlifyIdentity.on('init', user => {
                    if (user && window.location.pathname.includes('/admin')) {
                        window.location.href = '/admin';
                    }
                });
                netlifyIdentity.init();
            }
            
            // Check for PWA support
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/sw.js')
                        .catch(err => console.log('Service Worker failed:', err));
                });
            }
            
            // Offline support
            window.addEventListener('online', () => {
                utils.showNotification('Back online!', 'success');
                if (state.game && state.connection) {
                    state.connection.connect(state.game.code);
                }
            });
            
            window.addEventListener('offline', () => {
                utils.showNotification('You are offline', 'error');
                state.connection.updateStatus('disconnected');
            });
        };

        // Start the app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>